#!/usr/bin/env bash
#
# This script will build Open MPI for every compiler that is
# available through the module environment.
#

# script name
sn=`basename $0`

# Command line defaults
comp_classes="gcc,intel,pgi,pathscale"
comp_vers=""
ompi_version=0
tarball_dir=""
force_rebuild="False"
delay_remove="False"
justsummary="False"
hpcsoft_dir_default="/usr/projects/hpcsoft"
os=""
machine=""
base_pref_override=""
ompi_name="openmpi"
comp_mods=""

function description {
    echo "$sn Description:"
    echo -e "\tThis script will build Open MPI for the specified compilers. It"
    echo -e "\trequires the modules system to be available."
    echo -e "\tOpen MPI will be installed to:"
    echo -e "\tHPCSOFT_DIR/OS/MACH_NAME/openmpi/<openmpi version>-<compiler class>-<compiler version>"
    echo ""
}

function usage {
    echo "$sn usage:"
    echo "$sn --version=VER --tarball-dir=DIR [OPTIONS]"
    echo ""
    echo "OPTIONS:"
    echo -e "\t--version=VER"
    echo -e "\t\tSpecify the version of Open MPI to install. Required. Used to determine"
    echo -e "\t\tversion, source and installation locations."
    echo -e "\t--tarball-dir=DIR"
    echo -e "\t\tSpecify the directory that contains Open MPI source tarballs. Required."
    echo -e "\t--compiler-class=CLASS"
    echo -e "\t\tSpecify which class of compiler to use. CLASS can be a comma-separated"
    echo -e "\t\tlist. Default is $comp_classes."
    echo -e "\t--compiler-version=VER"
    echo -e "\t\tSpecify the version of the compiler to use. VER can be a comma-separated list."
    echo -e "\t\tIf the system gnu compilers are to be used, VER can contain the word 'system'"
    echo -e "\t\tto tell the script to use those compilers. No module files will be used for"
    echo -e "\t\tthat case. If this option is not used, Open MPI will be built for every"
    echo -e "\t\tversion of the compilers found."
    echo -e "\t--compiler-modules=MOD1[,MOD2...]"
    echo -e "\t\tSpecify compiler modules to use. This optional option takes a comma-separated"
    echo -e "\t\tlist of compiler modules. It will be against modulefiles given in this list"
    echo -e "\t\tthat this script will build Open MPI. The build attempts will be in the same"
    echo -e "\t\torder specified in the list. Overrides --compiler-class and --compiler-version."
    echo -e "\t--hpcsoft-dir=HPCSOFT_DIR"
    echo -e "\t--os-name=OS"
    echo -e "\t--machine-name=MACH_NAME"
    echo -e "\t--ompi-name=OMPI_NAME"
    echo -e "\t\tThese options manipulate the path that the builds of Open MPI will be put in:"
    echo -e "\t\tHPCSOFT_DIR/OS/MACH_NAME/OMPI_NAME"
    echo -e "\t\tDefault values for these options are as follows:"
    echo -e "\t\t- HPCSOFT_DIR: ${hpcsoft_dir_default}"
    echo -e "\t\t- OS: string returned by hpcsoft's sys_os script to find the OS string."
    echo -e "\t\t- MACH_NAME: string returned by hpcsoft's sys_name script."
    echo -e "\t\t- OMPI_NAME: ${ompi_name}"
    echo -e "\t--base-prefix=PATH"
    echo -e "\t\tOver-ride the above determined prefix with PATH. This allows the builds of"
    echo -e "\t\tOpen MPI to be installed in a directory outside of hpcsoft space. Hpcsoft"
    echo -e "\t\tutilities still need to be available in HPCSOFT_DIR."
    echo -e "\t--force-rebuild"
    echo -e "\t\tIf the build for a particular combination of compiler and mpi library has"
    echo -e "\t\talready been done, building that combination again is by default not done."
    echo -e "\t\tWith this option, the previous build will be removed and the build will be"
    echo -e "\t\tdone again."
    echo -e "\t--delay-removal"
    echo -e "\t\tPut off the removal of the previous build will be put off as long as possible."
    echo -e "\t\tThe default behavior is to remove the previous build as soon as it is detected"
    echo -e "\t\twhich is before any build commands are done. With this option, the removal"
    echo -e "\t\twill happen right before the 'make install' step. This option is not a good"
    echo -e "\t\tidea unless it is known beforehand that the user running this script can"
    echo -e "\t\tremove the previous build. In that case, it is better to discover not being"
    echo -e "\t\table to remove the previous build as soon as possible (before any build"
    echo -e "\t\tcommands are done). The timing of when the previous build is actually removed"
    echo -e "\t\tcan be seen by looking at the make log for that build."
    echo -e "\t--summary"
    echo -e "\t\tPrint the summary and then exit without doing anything."
}

# Function to build Open MPI. It will take care of all actions needed to install
# Open MPI from tarball to final installation.
#
# Usage:
#   build_ompi VERSION PREFIX TARBALL_DIR CNAME CVER SUMMARY REBUILD DELAY
#
# Input Parameters:
# - VERSION: version of Open MPI to build
# - PREFIX: installation prefix
# - TARBALL_DIR: location of Open MPI source tarballs
# - CNAME: name of the compiler being used
# - CVER: version of the compiler being used
# - SUMMARY: Boolean flag to tell build_ompi to just print a summary and exit.
#   True or False.
# - REBUILD: Boolean flag to tell build_ompi to force a rebuild of an already
#   finished build. True or False.
# - DELAY: Boolean flag to tell build_ompi to hold of removing previous builds
#   of Open MPI. True or False.
#
# Return Values:
# - 0: build was done successfully
# - 1: build was done previously
# - 2: build unsuccessful
function build_ompi {
    local ompi_version="$1"
    local install_pref="$2"
    local tarball_dir="$3"
    local comp_name="$4"
    local comp_ver="$5"
    local justsummary="$6"
    local force_rebuild="$7"
    local delay_remove="$8"
    local ompi_tarball
    local ompi_tarball_md5sum
    local ompi_src_dir
    local ompi_src_patches
    local platform_file
    local ompi_configure_envs
    local ompi_configure_options
    local ompi_make_options
    local post_install_scripts
    local build_config
    local build_summary
    local delete_install_pref
    local logs
    local build_stage_completed
    local problem
    local script
    local patch
    local tarball
    local test_md5sum
    local ret
    local tar_compress
    local compress_flag
    local configure_command
    local make_command
    local make_install_command

    echo "Building Open MPI $ompi_version for $comp_name $comp_ver"

    build_config=$(pwd)"/${ompi_version}/build_config"

    # First, reset all parameters that can be set in build_config
    unset ompi_tarball
    unset ompi_tarball_md5sum
    unset ompi_src_dir
    unset ompi_src_patches
    unset platform_file
    unset ompi_configure_envs
    unset ompi_configure_options
    unset ompi_make_options
    unset post_install_scripts
    
    # Source the build configuration file
    . $build_config
    if [[ $? != 0 ]]; then
        echo -e "\tProblem sourcing build_config."
        return 2
    fi
    # check parameters that should be set in build_config
    if [ -z "$ompi_tarball" ] || [ -z "$ompi_src_dir" ] \
        || [ -z "$platform_file" ] || [ -z "$ompi_tarball_md5sum" ]; then
        echo -e "\tompi_tarball, ompi_tarball_md5sum, ompi_src_dir, and platform_file where not successfully defined in build_config."
        return 2
    fi
    tarball="${tarball_dir}/${ompi_tarball}"
    # add the full path to the platform file
    platform_file=`pwd`"/${ompi_version}/${platform_file}"


    # Print a summary
    echo -e "\tCompiler: $comp_name $comp_ver"
    echo -e "\tTarball: ${tarball}"
    echo -e "\tSource directory name: $ompi_src_dir"
    echo -e "\tInstallation location: $install_pref"
    echo -e "\tPlatform file: $platform_file"
    echo -e "\tPatches: ${ompi_src_patches[*]:-None}"
    echo -e "\tConfigure Environment Variables: ${ompi_configure_envs:-None}"
    echo -e "\tConfigure Options: ${ompi_configure_options:-None}"
    echo -e "\tMake Options: ${ompi_make_options:-None}"
    echo -e "\tPost Installation Scripts: ${post_install_scripts[*]:-None}"

    if [ "$justsummary" == "True" ]; then
        echo -e "\tIn summary only mode, exiting."
        return 0
    fi

    # Build summary file; this is only created after a successful build
    build_summary="${install_pref}/build_summary"

    # check for a previous installation
    delete_install_pref=False
    if [ -d "$install_pref" ]; then
        # There was a previous attempt. Check to see if it completed.
        if [ -e "$build_summary" ]; then
            # The previous build attempt was successful.
            if [ "$force_rebuild" == "True" ]; then
                echo -ne "\tRemoving old installation in ${install_pref}..."
                delete_install_pref=True
            else
                echo -e "\tpreviously built"
                return 1
            fi
        else
            # The previous build attempt was not successful
            echo -ne "\tRemoving previous build that was not complete..."
            delete_install_pref=True
        fi
        if [ "$delete_install_pref" == True ]; then
            # We're not delaying the removal of the previous build. Just
            # remove it.
            if [ "$delay_remove" == "False" ]; then
                rm -rf $install_pref >> /dev/null 2>&1
                if [ -d "$install_pref" ]; then
                    echo "Failure"
                    return 2
                else
                    echo "Success"
                fi
            else
                # We're putting off removing the previous build until right
                # before 'make install'.
                echo "Delayed"
            fi
        fi
    fi

    # Check that the platform file exists
    if [ ! -f "$platform_file" ]; then
        echo -e "\t${platform_file} not present"
        return 2
    fi

    # Check that the tarball exists
    if [ ! -f "${tarball}" ]; then
        echo -e "\t${tarball} not available"
        return 2
    fi

    # Check the md5sum of the source tarball to make sure it is what
    # build_config says it should be.
    echo -ne "\tChecking md5sum of ${tarball}..."
    test_md5sum=`md5sum ${tarball_dir}/${ompi_tarball} | awk '{print $1}'`
    if [ "$test_md5sum" != "$ompi_tarball_md5sum" ]; then
        echo "Failure"
        echo -e "\tExpected md5sum: ${ompi_tarball_md5sum}"
        echo -e "\tComputed md5sum: ${test_md5sum}"
        return 2
    else
        echo "Success"
    fi

    # figure out if the tarball is gzip or bzip2
    tar_compress=`file ${tarball_dir}/${ompi_tarball}`
    if `echo $tar_compress | grep -q bzip2`; then
        compress_flag='j'
    elif `echo $tar_compress | grep -q gzip`; then
        compress_flag='z'
    else
        echo -e "\tUnable to determine how $ompi_tarball was compressed"
        return 2
    fi

    # Enter the version directory
    pushd $ompi_version > /dev/null 2>&1

    # remove any previous untarred directory
    if [ -e "${ompi_src_dir}" ]; then
        echo -ne "\tRemoving old Open MPI source directory ${ompi_src_dir}..."
        rm -rf ${ompi_src_dir} >> /dev/null 2>&1
        if [ -e "${ompi_src_dir}" ]; then
            echo "Failure"
            return 2
        fi
        echo "Success"
    fi

    # untar
    echo -en "\tUntarring tarball..."
    if ! tar x${compress_flag}f ${tarball}; then
        echo "Failure"
        return 2
    fi
    echo "Success"
    if [ ! -d "${ompi_src_dir}" ]; then
        echo -e "\tExtracting ${tarball} did not extract the ${ompi_src_dir} directory"
        return 2
    fi

    # Now go in to the ompi source directory
    cd ./${ompi_src_dir} >> /dev/null 2>&1

    # Keep a list of logs that need to be kept. It expands depending on how
    # far the installation gets
    logs=( )
    # Flag to keep track of what stage of the build has been successfully
    # completed.
    build_stage_completed="none"
    # Flag to track if there are issues during patching or post-installation-
    # script execution
    problem="False"

    # Apply any needed patches
    if [ -z "$ompi_src_patches" ]; then
        build_stage_completed="patches"
    else
        logs+=( "patches_output.log" )
        touch patches_output.log
        for patch in ${ompi_src_patches[@]}; do
            echo -ne "\tPatching OMPI source using ${patch}..."
            echo -e "\tPatching source using ${pat}" >> patches_output.log
            patch -p1 < ../$patch >> patches_output.log 2>&1
            if [[ $? == 0 ]]; then
                echo "Success" | tee -a patches_output.log
            else
                echo "Failure" | tee -a patches_output.log
                problem=True
            fi
        done
        if [ "$problem" == "False" ]; then
            build_stage_completed="patches"
            echo "Patching success" >> patches_output.log
        else
            echo "Patching failed" >> patches_output.log
        fi
    fi

    # Run configure
    if [ "$build_stage_completed" == "patches" ]; then
        echo -ne "\tRunning configure..."
        logs+=( "configure_output.log" "config.log" )
        configure_command="$ompi_configure_envs /usr/bin/time -p -a -o configure_output.log ./configure $ompi_configure_options --with-platform=$platform_file --prefix=$install_pref >> configure_output.log 2>&1"
        echo "Running configure via the following command:" > configure_output.log
        echo "$configure_command" >> configure_output.log
        eval $configure_command
        if [[ $? == 0 ]]; then
            build_stage_completed="configure"
            echo "Success" | tee -a configure_output.log
        else
            echo "Failure" | tee -a configure_output.log
        fi
    fi

    # run make
    if [ "$build_stage_completed" == "configure" ]; then
        echo -ne "\tRunning make..."
        logs+=( "make_output.log" )
        make_command="/usr/bin/time -p -a -o make_output.log make $ompi_make_options >> make_output.log 2>&1"
        echo "Running make via the following command:" > make_output.log
        echo "$make_command" >> make_output.log
        eval $make_command
        if [[ $? == 0 ]]; then
            build_stage_completed="make"
            echo "Success" | tee -a make_output.log
        else
            echo "Failure" | tee -a make_output.log
        fi
    fi

    # If removal of the installation directory was delayed, now is the time to
    # remove it.
    if [ "$build_stage_completed" == "make" ]; then
        if [ "$delay_remove" == "False" ]; then
            build_stage_completed="delayedinstallremove"
        else
            echo -ne "\tRemoving old installation directory ${install_pref}..."
            rm -rf $install_pref >> /dev/null 2>&1
            if [ -d "$install_pref" ]; then
                echo "Failure"
            else
                echo "Success"
                build_state_completed="delayedinstallremove"
            fi
        fi
    fi

    # make install
    if [ "$build_stage_completed" == "delayedinstallremove" ]; then
        echo -ne "\tRunning make install..."
        logs+=( "make_install_output.log" )
        make_install_command="make install >> make_install_output.log 2>&1"
        echo "Running make install via the following command:" > make_install_output.log
        echo "$make_install_command" >> make_install_output.log
        eval $make_install_command
        if [[ $? == 0 ]]; then
            build_stage_completed="makeinstall"
            echo "Success" | tee -a make_install_output.log
        else
            echo "Failure" | tee -a make_install_output.log
        fi
    fi

    problem="False"
    # Run post installation scripts, if any
    if [ "$build_stage_completed" == "makeinstall" ]; then
        if [ -z "$post_install_scripts" ]; then
            build_stage_completed="postinstallscripts"
        else
            echo -e "\tRunning Post Installation Scripts"
            logs+=( "post_install_output.log" )
            touch post_install_output.log
            for script in ${post_install_scripts[@]}; do
                echo -ne "\tRunning post install script ${script}..."
                echo "Running post install script $script" >> post_install_output.log
                eval ../${script} $install_pref >> post_install_output.log
                if [[ $? == 0 ]]; then
                    echo "Success" | tee -a post_install_output.log
                else
                    echo "Failure" | tee -a post_install_output.log
                    problem="True"
                fi
            done
            if [ "$problem" == "False" ]; then
                build_stage_completed="postinstallscripts"
                echo "Running of Post Installation Scripts completed successfully" >> post_install_output.log
            else
                echo "Running of Post Installation Scripts failed" >> post_install_output.log
            fi
        fi
    fi

    # tar up log files and put in the parent directory
    tar cjf build_logs.tar.bz2 "${logs[@]}"
    mv build_logs.tar.bz2 ..

    # go back to the version directory
    cd ..
    # remove the source directory
    rm -rf ${ompi_src_dir}

    # Based on how far the build got, exit appropriately.
    if [ "$build_stage_completed" == "postinstallscripts" ]; then
        # Build was successful. Create build_summary which should be in install_dir
        echo "Open MPI v$ompi_version for $build_name" > $build_summary
        echo "Built by: $USER" >> $build_summary
        echo "Built on: "`date` >> $build_summary
        echo "Tarball used to build: $ompi_tarball" >> $build_summary
        echo "Compiler used: $comp_name $comp_ver" >> $build_summary
        echo "Loaded modules:" >> $build_summary
        module list >> $build_summary 2>&1
        # Move log file tarball to install_pref
        mv build_logs.tar.bz2 $install_pref
        ret=0
    else
        # Build failed. Rename the build logs tarball to something more descriptive.
        if [ -e build_logs.tar.bz2 ]; then
            mv build_logs.tar.bz2 ${machine}_${comp_name}-${comp_ver}_build_logs.tar.bz2
        fi
        ret=2
    fi
    # cd back to the top-level directory; currently in the version directory
    popd >> /dev/null 2>&1

    return $ret
}

# Parse command line arguments
for arg in $*; do
    case $arg in
        --version=*)
            ompi_version=`echo $arg | sed 's/[-a-zA-Z0-9]*=//'`
            ;;
        --tarball-dir=*)
            tarball_dir=`echo $arg | sed 's/[-a-zA-Z0-9]*=//'`
            ;;
        --compiler-class=*)
            comp_classes=`echo $arg | sed 's/[-a-zA-Z0-9]*=//'`
            ;;
        --compiler-version=*)
            comp_vers=`echo $arg | sed 's/[-a-zA-Z0-9]*=//'`
            ;;
        --compiler-modules=*)
            comp_mods=`echo $arg | sed 's/[-a-zA-Z0-9]*=//'`
            ;;
        --hpcsoft-dir=*)
            hpcsoft_dir=`echo $arg | sed 's/[-a-zA-Z0-9]*=//'`
            ;;
        --os-name=*)
            os=`echo $arg | sed 's/[-a-zA-Z0-9]*=//'`
            ;;
        --machine-name=*)
            machine=`echo $arg | sed 's/[-a-zA-Z0-9]*=//'`
            ;;
        --ompi-name=*)
            ompi_name=`echo $arg | sed 's/[-a-zA-Z0-9]*=//'`
            ;;
        --base-prefix=*)
            base_pref_override=`echo $arg | sed 's/[-a-zA-Z0-9]*=//'`
            ;;
        --force-rebuild)
            force_rebuild="True"
            ;;
        --delay-removal)
            delay_remove="True"
            ;;
        --summary)
            justsummary="True"
            ;;
        '-h' | '--help')
            description
            usage
            exit 0
            ;;
        *)
            #Unknown option
            echo "$sn: unknown command line option $arg"
            usage
            exit 1
            ;;
    esac
done

if [ "$ompi_version" == 0 ]; then
    echo "$sn Error: --version not used."
    usage
    exit 1
fi

# Make sure a directory with the same name as ompi_version exists.
if [ ! -d "$ompi_version" ]; then
    echo "$sn Error: directory $ompi_version does not exist"
    exit 1
fi

# Check the build_config file
if [ ! -f "${ompi_version}/build_config" ]; then
    echo "Unable to find build_config file in $ompi_version."
    exit 1
fi

# Check the tarball directory
if [ -z "$tarball_dir" ]; then
    echo "$sn Error: --tarball-dir not used."
    usage
    exit 1
fi
if [ ! -d "$tarball_dir" ]; then
    echo "$sn Error: $tarball_dir does not exits."
    exit 1
fi

# Set hpcsoft_dir to the default if needed
if [ -z "$hpcsoft_dir" ]; then
    hpcsoft_dir=$hpcsoft_dir_default
fi

# Check hpcsoft_dir
if [ ! -d "$hpcsoft_dir" ]; then
    echo "$sn Error: $hpcsoft_dir does not exist."
    exit 1
fi

# Check for hpcsoft utilities
if [ ! -d "$hpcsoft_dir/utilities/.git" ]; then
    echo "$sn Error: $hpcsoft_dir/utilities does not contain a proper hpcsoft utilities repository"
    exit 1
fi

hpcsoft_util=$hpcsoft_dir/utilities

# figure out the OS name
if [ "$os" == "" ]; then
    if [ -e "${hpcsoft_util}/bin/sys_os" ]; then
        os=`${hpcsoft_util}/bin/sys_os`
    else
        echo "$sn Error: ${hpcsoft_util}/bin/sys_os does not exist and --os-name not used."
        exit 1
    fi
fi

# Check for the hpcsoft_dir/os directory
if [ ! -d "${hpcsoft_dir}/${os}" ]; then
    echo "$sn Error: ${hpcsoft_dir}/${os} does not exist."
    exit 1
fi

# figure out the machine name
if [ "$machine" == "" ]; then
    if [ -e "${hpcsoft_util}/bin/sys_name" ]; then
        machine=`${hpcsoft_util}/bin/sys_name`
    else
        echo "$sn Error: ${hpcsoft_util}/bin/sys_name does not exist and --machine-name not used."
        exit 1
    fi
fi

if [ "$base_pref_override" == "" ]; then
    # Check for the hpcsoft_dir/os directory
    if [ ! -d "${hpcsoft_dir}/${os}" ]; then
        echo "$sn Error: ${hpcsoft_dir}/${os} does not exist."
        exit 1
    fi
    # Check for the hpcsoft_dir/os/machine directory
    if [ ! -d "${hpcsoft_dir}/${os}/${machine}" ]; then
        echo "$sn Error: ${hpcsoft_dir}/${os}/${machine} does not exist."
        exit 1
    fi
    # Directory to install Open MPI to. Each build will go in this directory.
    base_pref="${hpcsoft_dir}/${os}/${machine}/${ompi_name}"
else
    base_pref="$base_pref_override"
fi

# If no compiler modules were given on the command line, look for a config file
# in the version directory and use that if it is there.
if [ -z "$comp_mods" ]; then
    config_file=`pwd`"/${ompi_version}/build_multiple_config"
    if [ -e "$config_file" ]; then
        echo "Found config file $config_file"
        unset compiler_list
        . $config_file
        comp_mods=$compiler_list
    fi
fi

# Grab some needed functions for dealing with the environment modulefiles.
if [ -e ${hpcsoft_util}/lib/envmodules_helpers.bash ]; then
    source ${hpcsoft_util}/lib/envmodules_helpers.bash
else
    echo "${hpcsoft_util}/lib/envmodules_query.bash does not exist. Exiting."
    exit 1
fi

# Call check_modules from envmodules_module_queryfuncs.bash
check_modules
if [ $? != 0 ]; then
    exit 1
fi

# figure out the list of modules associated with the compiler classes
if [ "$comp_mods" != "" ]; then
    # separate the comma-separated list in comp_mods into a space-separated
    # list
    comps=`echo $comp_mods | sed 's/,/ /g'`
    # now check that each exists
    for comp in $comps; do
        if [ "$comp" != "gcc/system" ]; then
            module_exists $comp
            if [[ $? != 0 ]]; then
                echo "Error: $comp does not exist"
                exit 1
            fi
        fi
    done
else
    # use functions defined in envmodules_module_queryfuncs.bash
    # to gather modules from the environment
    comps=`find_compilers "$comp_classes" "$comp_vers"`
fi
# Now, comps should be a space-separated list that is a list of compiler
# modules. All of the modules should have been verified to exist.

# First, print a summary
echo ""
echo "Summary"
echo "Machine name: $machine"
echo "OS version: $os"
echo "Open MPI version: $ompi_version"
echo "Install path: $base_pref"
echo "Tarball directory: $tarball_dir"
echo "Forcing rebuild? $force_rebuild"
if [ "$force_rebuild" == "True" ]; then
    echo "Delaying removal of old builds: $delay_remove"
fi
echo ""
echo "The following compiler modules will be used:"
echo $comps
echo ""

if [ "$justsummary" == "False" ]; then
    # check that base_pref exists
    if [ ! -d "$base_pref" ]; then
        mkdir $base_pref
        if [[ $? != 0 ]]; then
            echo "$0 Error: unable to create $base_pref"
            exit 1
        fi
        eval "${hpcsoft_util}/bin/check_hpcsoft_perms.py $base_pref >> /dev/null 2>&1"
    fi
else
    # Ask to print out individual build summaries
    echo -n "Print individual build summaries? [y/N] "
    read cont_ques
    if [ "$cont_ques" != "y" ]; then
        exit 0
    fi
fi

# Keep track of what builds do or don't pass
summary=( )

for comp in $comps; do
    module_compiler_load $comp >> /dev/null 2>&1
    if [[ $? != 0 ]]; then
        echo ""
        echo "Problem loading $comp" | tee -a $summary_log_file
        continue
    fi
    # Check for the needed env variables.
    if [ -n "$LCOMPILER" ] && [ -n "$LCOMPILERVER" ] \
        && [ -n "$LCOMPILERMAJVER" ]; then
        comp_class=$LCOMPILER
        comp_ver=$LCOMPILERVER
        comp_mver=$LCOMPILERMAJVER
        build_name=${comp_class}-${comp_ver}
        echo ""
        echo "-----------------------------------------------------------------"
        echo "${build_name} using ${comp_class} ${comp_ver}"

        # install prefix
        install_pref=${base_pref}/${ompi_version}-${build_name}

        # Call the function that will build Open MPI.
        build_ompi $ompi_version $install_pref $tarball_dir $comp_class $comp_ver $justsummary $force_rebuild $delay_remove
        build_ompi_ret=$?

        if [ "$justsummary" == "False" ]; then
            if [[ $build_ompi_ret == 0 ]]; then
                # set up correct permissions on install_prefix
                eval "${hpcsoft_util}/bin/check_hpcsoft_perms.py $install_prefix > /dev/null 2>&1"
                summary+=( "$build_name    Build successful" )
            elif [[ $build_ompi_ret == 1 ]]; then
                summary+=( "$build_name    Previously Built" )
            else
                summary+=( "$build_name    Build failed" )
            fi
        fi
    else # some of the needed compiler env variables are not set
        echo "LCOMPILER, LCOMPILERVER and/or LCOMPILERMAJVER are not defined in $comp; unable to determine compiler info"
        summary+=( "$build_name    Problem loading $comp" )
    fi
    module_compiler_remove $comp
done # loop over compiler modules

# Print out results summary
if [ "$justsummary" == "False" ]; then
    echo -e "\n"
    echo "Open MPI v${ompi_version} Build Summary:"
    for result in "${summary[@]}"; do
        echo "$result"
    done
fi
